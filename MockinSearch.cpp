#include <windows.h>
#include <tchar.h>
#include <iostream>
#include "Tlhelp32.h"
#include <vector>
#include "psapi.h"
#include <utility>
#include <dbghelp.h>
#include <stdio.h>
#include <filesystem>
#include <fstream>
#include <winnt.h>
#include <exception>

/*
* A basic PoC to search for DLLs that have default RWX sections.
* Injection functions have not been included for obvious reasons.
* I've included an example function to load a HModule and calculate it's offset address, you will need to tie it into the recursive code and add relevant logic, this is to avoid any script kiddies using this for nefarious purposes.
* Any suggestions on how I can improve this code, feel free to reach out.
* 
* DISCLAIMER: 
* - The provided DLL injection code is intended strictly for educational and research purposes only. 
* - The code demonstrates a technique used for learning about the underlying mechanisms of PE files and exploring the concept of DLL injection via relevant PE sections. 
* - Using this code in any unauthorized or malicious manner, such as in production systems or with harmful intent, is strictly prohibited and illegal. 
* - The author and the platform where this disclaimer is presented shall not be held responsible for any misuse or harm caused by the code's implementation. 
* - It is the sole responsibility of the user to comply with all applicable laws and regulations when using or modifying this code.
*/

bool anyInjectable = 0;

/// <summary>
/// Enumerates module information for a given process ID.
/// </summary>
/// <param name="processID"></param>
/// <returns>A vector of tuples with the process ID, file path and handle</returns>
std::vector<std::tuple<DWORD, std::string, HMODULE>> GetModules(DWORD processID)
{
    HMODULE hMods[1024];
    HANDLE hProcess;
    DWORD cbNeeded;
    unsigned int i;
    std::vector<std::tuple<DWORD, std::string, HMODULE>> modules;
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
        PROCESS_VM_READ,
        FALSE, processID);
    if (NULL == hProcess)
        return modules; // Empty
    if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))
    {
        for (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)
        {
            TCHAR szModName[MAX_PATH];
            if (GetModuleFileNameEx(hProcess, hMods[i], szModName,
                sizeof(szModName) / sizeof(TCHAR)))
            {
                std::wstring wideStringM(szModName);
                std::string utf8StringM(wideStringM.begin(), wideStringM.end());
                modules.push_back(make_tuple(processID, utf8StringM, hMods[i]));
            }
        }
    }
    CloseHandle(hProcess);
    return modules;
}

/// <summary>
/// Trims the section name values so no null or non-printable chars.
/// </summary>
/// <param name="name">section name as BYTE*</param>
/// <param name="size">size of section name</param>
/// <returns>Trimmed std::string</returns>
std::string TrimSectionName(const BYTE* name, size_t size) {
    std::string trimmedName(reinterpret_cast<const char*>(name), size);
    // Trim leading and trailing null characters
    trimmedName.erase(std::remove(trimmedName.begin(), trimmedName.end(), '\0'), trimmedName.end());
    // Remove non-printable characters
    trimmedName.erase(std::remove_if(trimmedName.begin(), trimmedName.end(), [](unsigned char c) { return !std::isprint(c); }), trimmedName.end());
    return trimmedName;
}

/// <summary>
/// Retrieves the section names for a given module and checks the associated permissions.
/// </summary>
/// <param name="moduleBase"></param>
/// <returns>A vector of section names with RWX permissions</returns>
std::vector<std::string> GetInjectablePESectionNames(std::string path)
{
    std::vector<std::string> sectionNames;
    try {
        IMAGE_DOS_HEADER dosHeader;
        IMAGE_NT_HEADERS ntHeader;
        std::vector<IMAGE_SECTION_HEADER> sectionHeaders;
        std::ifstream file(path, std::ios::binary);
        file.read(reinterpret_cast<char*>(&dosHeader), sizeof(dosHeader));
        if (dosHeader.e_magic != 0x5A4D) { // "MZ" in little-endian
            //std::cerr << "Invalid PE signature." << std::endl;
            return sectionNames; //NULL
        }
        file.seekg(dosHeader.e_lfanew, std::ios::beg);
        file.read(reinterpret_cast<char*>(&ntHeader), sizeof(ntHeader));
        if (ntHeader.Signature != 0x4550) { // "PE" in little-endian
            //std::cerr << "Invalid PE file signature." << std::endl;
            return sectionNames; //NULL
        }
        sectionHeaders.resize(ntHeader.FileHeader.NumberOfSections);
        file.read(reinterpret_cast<char*>(&sectionHeaders[0]), sizeof(IMAGE_SECTION_HEADER) * ntHeader.FileHeader.NumberOfSections);
        for (WORD i = 0; i < sectionHeaders.size(); i++)
        {
            std::string sectionName = TrimSectionName(sectionHeaders[i].Name, sizeof(sectionHeaders[i].Name));
            std::string permissions;
            // Check section characteristics for read, write, and execute permissions
            if (sectionHeaders[i].Characteristics & IMAGE_SCN_MEM_READ)
                permissions += "R";
            if (sectionHeaders[i].Characteristics & IMAGE_SCN_MEM_WRITE)
                permissions += "W";
            if (sectionHeaders[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
                permissions += "X";
            if (permissions == "RWX")
            {
                if (std::string(sectionName).size() > 1)
                {
                    std::cout << "\nInjectable DLL fle found: " << path << std::endl;
                    std::cout << "\tSection: " << std::string(sectionName) << " Permissions: " << permissions << std::endl;
                }
            }
        }
        file.close();
    }
    catch (std::exception& e) {
        std::cout << "ERR: " << e.what() << std::endl;
    }

    return sectionNames;
}

/// <summary>
/// Retrieve the relevant DLLs that have injectable RWX PE sections.
/// </summary>
/// <param name="modules"></param>
/// <returns>A vector of tuples with the process ID, file path and handle of relevant injectable DLLs</returns>
std::vector<std::tuple<DWORD, std::string, HMODULE>> GetInjectable(std::vector<std::tuple<DWORD, std::string, HMODULE>> modules)
{
    for (auto i = 0; i < modules.size(); i++)
    {
        HMODULE modBAddr = std::get<2>(modules[i]);
        HANDLE Handle = OpenProcess(
            PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
            FALSE, std::get<0>(modules[i]));
        TCHAR Buffer[MAX_PATH];
        if (GetModuleFileNameEx(Handle, 0, Buffer, MAX_PATH) && GetInjectablePESectionNames(std::get<1>(modules[i])).size() > 0)
        {
            if (GetInjectablePESectionNames(std::get<1>(modules[i])).size() > 0)
            {
                anyInjectable = 1;
            }
            std::wstring wideString(Buffer);
            std::string utf8String(wideString.begin(), wideString.end());
            std::cout << "Process Name: " << utf8String << std::endl;
            std::cout << "PID: " << std::get<0>(modules[i]) << std::endl;
            std::cout << "Module Path: " << std::get<1>(modules[i]) << std::endl; //Print the process ID and DLL module path.
            std::vector<std::string> sNames = GetInjectablePESectionNames(std::get<1>(modules[i]));
            if (sNames.size() > 1)
            {
                printf("\tPE Section Names for module at address: %p\n", modBAddr);
                printf("\n");
                for (auto b = 0; b < sNames.size(); b++)
                {
                    std::cout << "\t" << sNames[b] << std::endl;
                }
            }
        }
    }
    return modules;
}

/// <summary>
/// Custom function to test if a string ends with substring
/// </summary>
/// <param name="str">string to search</param>
/// <param name="suffix">substring to search for</param>
/// <returns>true or false</returns>
static bool endsWith(const std::string& str, const std::string& suffix)
{
    return str.size() >= suffix.size() && 0 == str.compare(str.size() - suffix.size(), suffix.size(), suffix);
}

/// <summary>
/// String converter
/// </summary>
/// <param name="str"></param>
/// <returns></returns>
LPCWSTR ConvertStringToLPCWSTR(const std::string str) {
    // Convert std::string to std::wstring
    std::wstring stw = std::wstring(str.begin(), str.end());
    // Get a pointer to the internal character buffer of the std::wstring
    LPCWSTR lpcwstr = stw.c_str();
    return lpcwstr;
}

/// <summary>
/// Attempts to load the module at the supplied path into the current process, searches for RWX section and calculates the offset.
/// </summary>
/// <param name="path"></param>
/// <returns>the RWX section offset and the loaded hmodule.</returns>
std::pair<HMODULE*, uintptr_t> LoadDLL(std::string path)
{
    unsigned char sc[] = "";
    LPCWSTR lPath = ConvertStringToLPCWSTR(path); //Convert to LPCWSTR
    HMODULE dll = nullptr;
    uintptr_t sectionOffsetAddress;

    try {
        dll = LoadLibraryW(lPath);
        if (dll == NULL) {//Couldn't load the DLL
            std::cout << "\n(!) Failed: couldn't load the DLL: " << path << std::endl;
            std::pair p = std::make_pair(&dll, sectionOffsetAddress);
            return p;
        }
    }
    catch (std::exception& e) {
        std::cout << "err: " << e.what() << std::endl;
    }
    //std::cout << "LoadDLL.." << std::endl;

    uintptr_t dllBaseAddress = reinterpret_cast<uintptr_t>(dll);
    // Get the DOS header and PE header
    IMAGE_DOS_HEADER* dosHeader = reinterpret_cast<IMAGE_DOS_HEADER*>(dll);
    IMAGE_NT_HEADERS* ntHeader = reinterpret_cast<IMAGE_NT_HEADERS*>(reinterpret_cast<char*>(dll) + dosHeader->e_lfanew);

    // Get the section header
    IMAGE_SECTION_HEADER* sectionHeader = IMAGE_FIRST_SECTION(ntHeader);
    for (unsigned int i = 0; i < ntHeader->FileHeader.NumberOfSections; i++) {
        char name[IMAGE_SIZEOF_SHORT_NAME + 1];
        memcpy(name, sectionHeader[i].Name, IMAGE_SIZEOF_SHORT_NAME);
        name[IMAGE_SIZEOF_SHORT_NAME] = '\0';

        std::string sectionName(name);
        size_t nullPos = sectionName.find_first_of('\0');
        if (nullPos != std::string::npos) {
            sectionName.resize(nullPos); // Trim the name to remove null characters
        }
        std::string permissions;
        // Check section characteristics for read, write, and execute permissions
        if (sectionHeader[i].Characteristics & IMAGE_SCN_MEM_READ)
            permissions += "R";
        if (sectionHeader[i].Characteristics & IMAGE_SCN_MEM_WRITE)
            permissions += "W";
        if (sectionHeader[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
            permissions += "X";
        if (permissions == "RWX")
        {
            // Calculate the section offset address using RVA and the DLL base address
            sectionOffsetAddress = dllBaseAddress + sectionHeader[i].VirtualAddress;
            std::cout << "DLL Loaded: " << path << std::endl;
            std::cout << "RWX Section long name: " << sectionName << " Section offset (injection point): 0x" << std::hex << sectionOffsetAddress << std::endl;
            //FreeLibrary(dll);

        }

    }
    std::pair p = std::make_pair(&dll, sectionOffsetAddress);
    return p;

}

int main(void)
{
    DWORD aProcesses[1024];
    DWORD cbNeeded;
    DWORD cProcesses;
    unsigned int i;
    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
        return 1;
    cProcesses = cbNeeded / sizeof(DWORD);
    std::cout << "\nSearching running processes for modules that have default sections with RWX permissions.." << std::endl;
    for (i = 0; i < cProcesses; i++)
    {
        std::vector<std::tuple<DWORD, std::string, HMODULE>> mods = GetModules(aProcesses[i]);
        GetInjectable(mods);
    }
    if (anyInjectable == 0) {
        std::cout << "\n(*)No modules with RWX sections were found within running processes" << std::endl;
    }
    std::cout << "\nSearching DLLs residing on the C drive..\n" << std::endl;
    //Enum and iterate filesystem DLLs
    try {
        for (std::filesystem::recursive_directory_iterator i("C:\\Program Files\\"), end; i != end; ++i) {
            if ((!is_directory(i->path()) && (std::filesystem::is_regular_file(i->path())))) {
                std::string fname = i->path().filename().string();
                if (endsWith(fname, ".dll")) {
                    //std::cout << i->path().string() << std::endl;
                    GetInjectablePESectionNames(i->path().string());

                }
            }
            else {
                continue;
            }
        }
    }
    catch (std::exception& e) {
        std::cout << "err: " << e.what() << std::endl;
    }
    std::string dllPath = "C:\\PATH\TO\VULNERABLE_DLL.DLL"; //Example path, change as needed
    std::pair p = LoadDLL(dllPath);
    return 0;
}
