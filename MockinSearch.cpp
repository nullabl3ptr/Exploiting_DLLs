#include <windows.h>
#include <tchar.h>
#include <iostream>
#include "Tlhelp32.h"
#include <vector>
#include "psapi.h"
#include <utility>
#include <dbghelp.h>
#include <stdio.h>
#include <winnt.h>

bool anyInjectable = 0;
/// <summary>
/// Prints the modules loaded for a given process ID, along with the handle.
/// </summary>
/// <param name="modules"></param>
void PrintModules(std::vector<std::tuple<DWORD, std::string, HMODULE>> modules) 
{
    for (auto i = 0; i < modules.size(); i++) {
        std::cout << "Process: " << std::get<0>(modules[i]) << std::endl;
        std::cout << "Module: " << std::get<1>(modules[i]) << std::endl;
        std::cout << "Handle: " << std::get<2>(modules[i]) << std::endl;
        std::cout << std::endl;
    }
}
/// <summary>
/// Enumerates module information for a given process ID.
/// </summary>
/// <param name="processID"></param>
/// <returns>A vector of tuples with the process ID, file path and handle</returns>
std::vector<std::tuple<DWORD, std::string, HMODULE>> GetModules(DWORD processID)
{
    HMODULE hMods[1024];
    HANDLE hProcess;
    DWORD cbNeeded;
    unsigned int i;
    std::vector<std::tuple<DWORD, std::string, HMODULE>> modules;
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
        PROCESS_VM_READ,
        FALSE, processID);
    if (NULL == hProcess)
        return modules; // Empty
    if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))
    {
        for (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)
        {
            TCHAR szModName[MAX_PATH];
            if (GetModuleFileNameEx(hProcess, hMods[i], szModName,
                sizeof(szModName) / sizeof(TCHAR)))
            {
                std::wstring wideStringM(szModName);
                std::string utf8StringM(wideStringM.begin(), wideStringM.end());
                modules.push_back(make_tuple(processID, utf8StringM, hMods[i]));
            }
        }
    }
    CloseHandle(hProcess);
    return modules;
}
/// <summary>
/// Retrieves the section names for a given module and checks the associated permissions.
/// </summary>
/// <param name="moduleBase"></param>
/// <returns>A vector of section names with RWX permissions</returns>
std::vector<std::string> GetInjectablePESectionNames(HMODULE moduleBase) {
    PIMAGE_NT_HEADERS NtHeader = ImageNtHeader(moduleBase);
    std::vector<std::string> sectionNames;
    if (NtHeader == nullptr) {
        return sectionNames;
    }
    PIMAGE_SECTION_HEADER sectionHeader = IMAGE_FIRST_SECTION(NtHeader);
    for (WORD i = 0; i < NtHeader->FileHeader.NumberOfSections; i++, sectionHeader++) {
        char sectionName[IMAGE_SIZEOF_SHORT_NAME + 1];
        sprintf_s(sectionName, "%.*s", IMAGE_SIZEOF_SHORT_NAME, sectionHeader->Name);
        std::string permissions;

        // Check section characteristics for read, write, and execute permissions
        if (sectionHeader->Characteristics & IMAGE_SCN_MEM_READ)
            permissions += "R";
        if (sectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE)
            permissions += "W";
        if (sectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE)
            permissions += "X";
        if (permissions == "RWX") {
            sectionNames.push_back(std::string(sectionName) += " " + permissions);
        }      
    }

    return sectionNames;
}

/// <summary>
/// Retrieve the relevant DLLs that have injectable RWX PE sections.
/// </summary>
/// <param name="modules"></param>
/// <returns>A vector of tuples with the process ID, file path and handle of relevant injectable DLLs</returns>
std::vector<std::tuple<DWORD, std::string, HMODULE>> GetInjectable(std::vector<std::tuple<DWORD, std::string, HMODULE>> modules)
{
    ///TODO: Enumerate PE sections and permissions for each DLL, if injectable then push tuple to vector.
    for (auto i = 0; i < modules.size(); i++) {
        HMODULE modBAddr = std::get<2>(modules[i]);
        HANDLE Handle = OpenProcess(
            PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
            FALSE, std::get<0>(modules[i]));
        TCHAR Buffer[MAX_PATH];
        if (GetModuleFileNameEx(Handle, 0, Buffer, MAX_PATH) && GetInjectablePESectionNames(modBAddr).size() > 0)
        {
            if (GetInjectablePESectionNames(modBAddr).size() > 0) {
                anyInjectable = 1;
            }
            std::wstring wideString(Buffer);
            std::string utf8String(wideString.begin(), wideString.end());
            std::cout << "Process Name: " << utf8String << std::endl;
            std::cout << "PID: " << std::get<0>(modules[i]) << std::endl;
            std::cout << "Module Path: " << std::get<1>(modules[i]) << std::endl; //Print the process ID and DLL module path.
            std::vector<std::string> sNames = GetInjectablePESectionNames(modBAddr);
            if (sNames.size() > 1) {
                printf("\tPE Section Names for module at address: %p\n", modBAddr);
                printf("\n");
                for (auto b = 0; b < sNames.size(); b++) {
                    std::cout << "\t" << sNames[b] << std::endl;
                }
            }  
        }
    }
   
    return modules;
}

int main(void)
{
    DWORD aProcesses[1024];
    DWORD cbNeeded;
    DWORD cProcesses;
    unsigned int i;
    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
        return 1;
    cProcesses = cbNeeded / sizeof(DWORD);
    for (i = 0; i < cProcesses; i++)
    {
        std::vector<std::tuple<DWORD, std::string, HMODULE>> mods = GetModules(aProcesses[i]);
        GetInjectable(mods);
    }
    if (anyInjectable == 0) {
        std::cout << "No modules with RWX sections were found within running processes" << std::endl;
    }
    return 0;
}